-- Initialize services and variables
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

-- Create or get folder for baseplates
local baseplateFolder = Workspace:FindFirstChild("InfiniteBaseplates")
if not baseplateFolder then
    baseplateFolder = Instance.new("Folder")
    baseplateFolder.Name = "InfiniteBaseplates"
    baseplateFolder.Parent = Workspace
end

-- Check for toggle state
if _G.InfiniteBaseplatesActive then
    -- If already active, disable
    _G.InfiniteBaseplatesActive = false

    -- Remove all baseplates
    for _, part in ipairs(baseplateFolder:GetChildren()) do
        if part.Name == "GrassBaseplate" then
            part:Destroy()
        end
    end
    return
end

-- Enable baseplates
_G.InfiniteBaseplatesActive = true

-- Baseplate settings
local baseplateSize = 2000
local baseplateSpacing = 0
local baseplateThickness = 4
local baseplateGrid = {}
local selectedColor = Color3.fromRGB(34, 139, 34)  -- Forest Green

-- Spawn position
local spawnPos = Vector3.new(4, -3, -481)

-- Exclusion zone (inside these corners)
local minX, minZ = -468, -957
local maxX, maxZ = 483, -7

-- Function to get Y position for baseplate
local function getBaseplateYPosition()
    local character = Player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local rayOrigin = character.HumanoidRootPart.Position
        local rayDirection = Vector3.new(0, -1000, 0)
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        raycastParams.FilterDescendantsInstances = {character, baseplateFolder}
        local raycastResult = Workspace:Raycast(rayOrigin, rayDirection, raycastParams)
        if raycastResult then
            return raycastResult.Position.Y - (baseplateThickness / 2) + 0.001
        else
            return spawnPos.Y
        end
    end
    return spawnPos.Y
end

-- Function to add a baseplate but cut out exclusion if needed
local function addGrassBaseplateWithHole(position)
    local key = tostring(position.X) .. "," .. tostring(position.Z)
    if baseplateGrid[key] then return end

    local baseplateY = getBaseplateYPosition()

    -- Calculate bounds of this baseplate
    local halfSize = baseplateSize / 2
    local leftX = position.X - halfSize
    local rightX = position.X + halfSize
    local frontZ = position.Z - halfSize
    local backZ = position.Z + halfSize

    -- If the baseplate intersects exclusion, split it into up to 4 parts
    local overlapX1 = math.max(leftX, minX)
    local overlapX2 = math.min(rightX, maxX)
    local overlapZ1 = math.max(frontZ, minZ)
    local overlapZ2 = math.min(backZ, maxZ)

    if leftX < maxX and rightX > minX and frontZ < maxZ and backZ > minZ then
        -- left part
        if leftX < minX then
            local part = Instance.new("Part")
            part.Name = "GrassBaseplate"
            part.Anchored = true
            part.Material = Enum.Material.SmoothPlastic
            part.Color = selectedColor
            part.Size = Vector3.new(minX - leftX, baseplateThickness, baseplateSize)
            part.Position = Vector3.new(leftX + (part.Size.X/2), baseplateY, position.Z)
            part.Transparency = 0.5
            part.CanCollide = true
            part.Parent = baseplateFolder
        end
        -- right part
        if rightX > maxX then
            local part = Instance.new("Part")
            part.Name = "GrassBaseplate"
            part.Anchored = true
            part.Material = Enum.Material.SmoothPlastic
            part.Color = selectedColor
            part.Size = Vector3.new(rightX - maxX, baseplateThickness, baseplateSize)
            part.Position = Vector3.new(maxX + (part.Size.X/2), baseplateY, position.Z)
            part.Transparency = 0.5
            part.CanCollide = true
            part.Parent = baseplateFolder
        end
        -- front part
        if frontZ < minZ then
            local part = Instance.new("Part")
            part.Name = "GrassBaseplate"
            part.Anchored = true
            part.Material = Enum.Material.SmoothPlastic
            part.Color = selectedColor
            part.Size = Vector3.new(math.min(baseplateSize, rightX-leftX), baseplateThickness, minZ - frontZ)
            part.Position = Vector3.new(position.X, baseplateY, frontZ + (part.Size.Z/2))
            part.Transparency = 0.5
            part.CanCollide = true
            part.Parent = baseplateFolder
        end
        -- back part
        if backZ > maxZ then
            local part = Instance.new("Part")
            part.Name = "GrassBaseplate"
            part.Anchored = true
            part.Material = Enum.Material.SmoothPlastic
            part.Color = selectedColor
            part.Size = Vector3.new(math.min(baseplateSize, rightX-leftX), baseplateThickness, backZ - maxZ)
            part.Position = Vector3.new(position.X, baseplateY, maxZ + (part.Size.Z/2))
            part.Transparency = 0.5
            part.CanCollide = true
            part.Parent = baseplateFolder
        end
    else
        -- No overlap with exclusion, normal baseplate
        local grassBaseplate = Instance.new("Part")
        grassBaseplate.Name = "GrassBaseplate"
        grassBaseplate.Size = Vector3.new(baseplateSize, baseplateThickness, baseplateSize)
        grassBaseplate.Anchored = true
        grassBaseplate.Material = Enum.Material.SmoothPlastic
        grassBaseplate.Color = selectedColor
        grassBaseplate.Position = position
        grassBaseplate.Transparency = 0.5
        grassBaseplate.CanCollide = true
        grassBaseplate.Parent = baseplateFolder
    end

    baseplateGrid[key] = true
end

-- Function to create baseplates in a square grid around the spawn
local function createBaseplatesGrid()
    local center = spawnPos
    local sizeMultiplier = baseplateSize + baseplateSpacing
    local gridRadius = 4  -- 9x9 grid

    for x = -gridRadius, gridRadius do
        for z = -gridRadius, gridRadius do
            local posX = center.X + (x * sizeMultiplier)
            local posZ = center.Z + (z * sizeMultiplier)
            addGrassBaseplateWithHole(Vector3.new(posX, center.Y, posZ))
        end
    end
end

-- Clear old baseplates if any
for _, part in ipairs(baseplateFolder:GetChildren()) do
    if part.Name == "GrassBaseplate" then
        part:Destroy()
    end
end
baseplateGrid = {}

-- Create initial baseplates
createBaseplatesGrid()

-- Continuously update baseplates around spawn (optional)
spawn(function()
    while _G.InfiniteBaseplatesActive do
        wait(1)
        createBaseplatesGrid()
    end
end)
