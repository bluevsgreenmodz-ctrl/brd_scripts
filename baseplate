-- Initialize services and variables
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

-- Create or get folder for baseplates
local baseplateFolder = Workspace:FindFirstChild("InfiniteBaseplates")
if not baseplateFolder then
    baseplateFolder = Instance.new("Folder")
    baseplateFolder.Name = "InfiniteBaseplates"
    baseplateFolder.Parent = Workspace
end

-- Check for toggle state
if _G.InfiniteBaseplatesActive then
    -- If already active, disable
    _G.InfiniteBaseplatesActive = false

    -- Remove all baseplates
    for _, part in ipairs(baseplateFolder:GetChildren()) do
        if part.Name == "GrassBaseplate" then
            part:Destroy()
        end
    end

    return
end

-- Enable baseplates
_G.InfiniteBaseplatesActive = true

-- Baseplate settings
local baseplateSize = 2000
local baseplateSpacing = 0
local baseplateThickness = 4
local baseplateGrid = {}
local selectedColor = Color3.fromRGB(34, 139, 34)  -- Forest Green

-- Spawn position
local spawnPosition = Vector3.new(4, -3, -481)

-- Exclusion zone corners
local exclusionCorners = {
    Vector3.new(-467, 3, -957),
    Vector3.new(-468, 3, -7),
    Vector3.new(483, 3, -7),
    Vector3.new(483, 3, -957),
}

-- Function to check if a position is inside the exclusion rectangle
local function isInsideExclusion(pos)
    local minX = math.min(exclusionCorners[1].X, exclusionCorners[2].X, exclusionCorners[3].X, exclusionCorners[4].X)
    local maxX = math.max(exclusionCorners[1].X, exclusionCorners[2].X, exclusionCorners[3].X, exclusionCorners[4].X)
    local minZ = math.min(exclusionCorners[1].Z, exclusionCorners[2].Z, exclusionCorners[3].Z, exclusionCorners[4].Z)
    local maxZ = math.max(exclusionCorners[1].Z, exclusionCorners[2].Z, exclusionCorners[3].Z, exclusionCorners[4].Z)

    return pos.X >= minX and pos.X <= maxX and pos.Z >= minZ and pos.Z <= maxZ
end

-- Function to get Y position for baseplate
local function getBaseplateYPosition()
    local character = Player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = character.HumanoidRootPart
        local rayOrigin = humanoidRootPart.Position
        local rayDirection = Vector3.new(0, -1000, 0)
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        raycastParams.FilterDescendantsInstances = {character, baseplateFolder}
        local raycastResult = Workspace:Raycast(rayOrigin, rayDirection, raycastParams)
        if raycastResult then
            return raycastResult.Position.Y - (baseplateThickness / 2) + 0.001
        else
            return spawnPosition.Y
        end
    end
    return spawnPosition.Y
end

-- Function to create a baseplate
local function addGrassBaseplate(position, allowHole)
    local key = tostring(position.X) .. "," .. tostring(position.Z)
    if baseplateGrid[key] then return end

    -- Skip if inside exclusion zone unless it's the spawn baseplate
    if isInsideExclusion(position) and position ~= spawnPosition and not allowHole then
        return
    end

    local grassBaseplate = Instance.new("Part")
    grassBaseplate.Name = "GrassBaseplate"
    grassBaseplate.Size = Vector3.new(baseplateSize, baseplateThickness, baseplateSize)
    grassBaseplate.Anchored = true
    grassBaseplate.Material = Enum.Material.SmoothPlastic
    grassBaseplate.Color = selectedColor
    grassBaseplate.Position = position
    grassBaseplate.Transparency = 0.5
    grassBaseplate.CanCollide = true
    grassBaseplate.Parent = baseplateFolder

    -- If this is the center plate, create a hole in the exclusion zone
    if allowHole then
        local minX = math.min(exclusionCorners[1].X, exclusionCorners[2].X, exclusionCorners[3].X, exclusionCorners[4].X)
        local maxX = math.max(exclusionCorners[1].X, exclusionCorners[2].X, exclusionCorners[3].X, exclusionCorners[4].X)
        local minZ = math.min(exclusionCorners[1].Z, exclusionCorners[2].Z, exclusionCorners[3].Z, exclusionCorners[4].Z)
        local maxZ = math.max(exclusionCorners[1].Z, exclusionCorners[2].Z, exclusionCorners[3].Z, exclusionCorners[4].Z)

        local hole = Instance.new("Part")
        hole.Name = "ExclusionHole"
        hole.Size = Vector3.new(maxX - minX, baseplateThickness + 0.1, maxZ - minZ)
        hole.Anchored = true
        hole.Position = Vector3.new((minX + maxX)/2, position.Y + 0.01, (minZ + maxZ)/2)
        hole.Transparency = 1
        hole.CanCollide = false
        hole.Parent = grassBaseplate
    end

    baseplateGrid[key] = grassBaseplate
end

-- Function to create baseplates in a square grid around spawn
local function createBaseplatesGrid()
    local gridRadius = 4  -- 9x9 grid
    local sizeMultiplier = baseplateSize + baseplateSpacing
    local baseplateY = getBaseplateYPosition()

    for x = -gridRadius, gridRadius do
        for z = -gridRadius, gridRadius do
            local platePos = Vector3.new(
                spawnPosition.X + (x * sizeMultiplier),
                baseplateY,
                spawnPosition.Z + (z * sizeMultiplier)
            )
            -- Only the exact center can have a hole
            local allowHole = (x == 0 and z == 0)
            addGrassBaseplate(platePos, allowHole)
        end
    end
end

-- Main loop to generate baseplates
spawn(function()
    -- Clear old baseplates if any
    for _, part in ipairs(baseplateFolder:GetChildren()) do
        if part.Name == "GrassBaseplate" then
            part:Destroy()
        end
    end
    baseplateGrid = {}

    -- Create initial baseplates
    createBaseplatesGrid()

    -- Continuously update baseplates
    spawn(function()
        while _G.InfiniteBaseplatesActive do
            wait(1)
            createBaseplatesGrid()
        end
    end)
end)
